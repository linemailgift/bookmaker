<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>本の表紙メーカー</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 全体のフォントと背景 */
        body { 
            font-family: 'Noto Sans JP', sans-serif; 
            background-color: #f0fdfa; 
            background-image: radial-gradient(#ccfbf1 1px, transparent 1px);
            background-size: 20px 20px;
        }
        canvas { touch-action: none; }

        /* --- ボタン（角丸あり） --- */
        .btn-rich {
            position: relative;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            z-index: 1;
            border: none; 
            backdrop-filter: blur(4px);
            border-radius: 9999px;
        }
        .btn-rich::before {
            content: "";
            position: absolute;
            top: 0; left: 0; right: 0; height: 50%;
            background: linear-gradient(to bottom, rgba(255,255,255,0.3), rgba(255,255,255,0));
            border-radius: 9999px;
            z-index: -1;
            pointer-events: none;
        }
        .btn-rich:not(:disabled):hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px -5px rgba(0,0,0,0.15);
            filter: brightness(1.1);
        }
        .btn-rich:not(:disabled):active {
            transform: translateY(0);
            box-shadow: 0 2px 5px -2px rgba(0,0,0,0.1);
        }
        .btn-rich:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            filter: grayscale(0.8);
        }
        /* 光沢アニメーション */
        .btn-shine { position: relative; }
        .btn-shine::after {
            content: "";
            position: absolute;
            top: 0; left: -150%; width: 100%; height: 100%;
            background: linear-gradient(120deg, transparent 0%, rgba(255, 255, 255, 0.6) 50%, transparent 100%);
            transform: skewX(-25deg);
            transition: none;
            pointer-events: none;
        }
        .btn-shine:not(:disabled):hover::after {
            animation: shine-anim 0.7s ease-in-out;
        }
        @keyframes shine-anim {
            0% { left: -150%; }
            100% { left: 150%; }
        }

        /* パネル */
        .rich-panel {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.8);
            box-shadow: 0 10px 30px -10px rgba(0, 0, 0, 0.05);
            border-radius: 12px;
        }

        /* ファイル入力 (枠なし・角なし) */
        input[type="file"] {
            background-color: transparent;
            border: none;
            border-radius: 0;
            padding: 0;
            width: 100%;
        }
        input[type="file"]::file-selector-button {
            border-radius: 0; border: none;
            margin-right: 1rem; padding: 0.5rem 1rem;
            background-color: #e2e8f0; color: #475569;
            font-weight: bold; cursor: pointer;
            transition: background 0.2s;
        }
        input[type="file"]::file-selector-button:hover { background-color: #cbd5e1; }
        
        /* スクロールバー */
        .custom-scrollbar::-webkit-scrollbar { width: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #f1f1f1; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
    </style>
</head>
<body class="min-h-screen flex flex-col text-gray-800">

    <!-- ヘッダー -->
    <header class="bg-gradient-to-r from-emerald-500 via-teal-500 to-cyan-600 p-4 shadow-lg relative overflow-hidden">
        <div class="container mx-auto flex justify-between items-center relative z-10">
            <h1 class="text-2xl font-extrabold text-white tracking-wide drop-shadow-md">
                本の表紙メーカー
            </h1>
        </div>
    </header>

    <!-- メインコンテンツ -->
    <main class="flex-grow container mx-auto p-6 flex flex-col lg:flex-row gap-8">
        
        <!-- 左カラム: 操作パネル -->
        <div class="w-full lg:w-1/3 flex flex-col gap-6">
            
            <!-- ステータス表示 -->
            <div id="statusBox" class="hidden p-4 rounded border-l-4 shadow-md transition-all duration-300 transform">
                <p id="statusMessage" class="text-sm font-bold flex items-center gap-2"></p>
            </div>

            <!-- 設定パネル -->
            <div class="rich-panel p-6 space-y-8">
                
                <!-- 1. 背景設定 -->
                <div>
                    <label class="block text-sm font-bold mb-3 text-gray-700 flex items-center gap-2">
                        <span class="text-emerald-600 font-extrabold text-xs">STEP 1</span>
                        モックアップ画像 (背景)
                    </label>
                    
                    <!-- サンプル選択 -->
                    <div class="bg-slate-50 p-3 border-b border-slate-200 mb-4">
                        <div class="text-xs text-slate-500 mb-2 font-bold">サンプルから選択</div>
                        <div id="sampleContainer" class="grid grid-cols-3 gap-3 max-h-48 overflow-y-auto pr-1 custom-scrollbar">
                            <div class="text-xs text-gray-400 col-span-3 py-6 text-center">読み込み中...</div>
                        </div>
                    </div>

                    <!-- ファイルアップロード -->
                    <div class="relative">
                        <div class="text-xs text-gray-500 mb-1 font-bold pl-1">または画像をアップロード</div>
                        <input type="file" id="inputMockup" accept="image/*" class="block w-full text-sm text-slate-500 cursor-pointer">
                    </div>
                </div>
                
                <div class="border-t border-dashed border-gray-300"></div>

                <!-- 2. 表紙設定 -->
                <div>
                    <label class="block text-sm font-bold mb-3 text-gray-700 flex items-center gap-2">
                        <span class="text-indigo-600 font-extrabold text-xs">STEP 2</span>
                        表紙画像 (中身)
                    </label>
                    
                    <div class="flex items-end gap-3">
                        <div class="flex-grow">
                             <input type="file" id="inputCover" accept="image/*" class="block w-full text-sm text-slate-500 cursor-pointer">
                        </div>
                        <!-- 合成ボタン -->
                        <button id="btnSynthesize" class="btn-rich btn-shine bg-gradient-to-br from-indigo-500 to-violet-600 text-white font-bold py-3 px-6 shadow-lg whitespace-nowrap disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center min-w-[100px]">
                            合成
                        </button>
                    </div>
                    
                    <!-- プレビュー -->
                    <div id="coverPreviewContainer" class="mt-4 hidden bg-slate-50 p-3 border border-slate-200 shadow-inner relative overflow-hidden">
                        <div class="flex justify-between items-center mb-2 relative z-10">
                            <p class="text-xs text-slate-500 font-bold">選択中の表紙:</p>
                            <span id="synthesizeStatus" class="text-xs font-bold text-orange-500 bg-white px-2 py-0.5 shadow-sm">未合成</span>
                        </div>
                        <img id="coverPreview" class="h-28 w-auto object-contain mx-auto shadow-sm relative z-10 bg-white" alt="Cover Preview">
                    </div>
                </div>
            </div>

            <!-- アクション -->
            <div class="grid grid-cols-2 gap-4">
                <button id="btnReset" class="btn-rich bg-gradient-to-b from-slate-100 to-slate-200 text-slate-600 font-bold py-3 px-4 shadow-sm hover:text-slate-800">
                    全クリア
                </button>
                <button id="btnDownload" class="btn-rich btn-shine bg-gradient-to-br from-cyan-500 to-blue-600 text-white font-bold py-3 px-4 shadow-lg disabled:opacity-50 disabled:cursor-not-allowed">
                    ダウンロード
                </button>
            </div>
        </div>

        <!-- 右カラム: キャンバス -->
        <div class="w-full lg:w-2/3 rich-panel shadow-xl flex justify-center items-center overflow-hidden relative min-h-[500px] bg-slate-100" id="canvasContainer">
            <!-- 背景パターン -->
            <div class="absolute inset-0 opacity-5 pointer-events-none" style="background-image: radial-gradient(#64748b 1px, transparent 1px); background-size: 30px 30px;"></div>
            
            <canvas id="mainCanvas" class="max-w-full max-h-[80vh] shadow-2xl hidden relative z-10 transition-transform duration-300"></canvas>
            
            <div id="placeholderText" class="text-slate-400 pointer-events-none text-center z-10">
                <p class="text-lg font-medium">ここに画像が表示されます</p>
                <p class="text-sm opacity-70 mt-2">左のパネルから設定してください</p>
            </div>
        </div>
    </main>

    <!-- フッター -->
    <footer class="bg-slate-800 text-slate-300 py-6 text-center text-sm mt-8 border-t border-slate-700">
        <p>&copy; 2025 chiikuji</p>
    </footer>

    <!-- JavaScript -->
    <script>
        // --- 設定: サンプル画像リスト (大文字小文字対応) ---
        const SAMPLE_FILES = [
            "1.png", "1.PNG",
            "2.png", "2.PNG",
            "3.png", "3.PNG",
            "4.png", "4.PNG",
            "5.png", "5.PNG",
            "6.png", "6.PNG"
        ];

        // --- 変数 ---
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const inputMockup = document.getElementById('inputMockup');
        const inputCover = document.getElementById('inputCover');
        const btnSynthesize = document.getElementById('btnSynthesize');
        const coverPreviewContainer = document.getElementById('coverPreviewContainer');
        const coverPreview = document.getElementById('coverPreview');
        const synthesizeStatus = document.getElementById('synthesizeStatus');
        const statusMessage = document.getElementById('statusMessage');
        const statusBox = document.getElementById('statusBox');
        const btnReset = document.getElementById('btnReset');
        const btnDownload = document.getElementById('btnDownload');
        const placeholderText = document.getElementById('placeholderText');
        const sampleContainer = document.getElementById('sampleContainer');

        let mockupImg = null;
        let coverImg = null;
        let points = []; 
        const MAX_POINTS = 4;
        let isSynthesized = false;
        let isDragging = false;
        let dragPointIndex = -1;
        const HIT_RADIUS = 20;

        // --- 初期化 ---
        window.addEventListener('DOMContentLoaded', initSampleGallery);

        function initSampleGallery() {
            sampleContainer.innerHTML = "";
            // ファイル名リストから画像を生成
            SAMPLE_FILES.forEach(fileName => {
                const img = document.createElement('img');
                img.src = fileName;
                img.className = "w-full h-24 object-cover cursor-pointer border-4 border-transparent hover:border-emerald-400 bg-white transition-all duration-200 shadow-sm hover:shadow-md hover:-translate-y-1";
                img.onclick = () => {
                    Array.from(sampleContainer.children).forEach(c => {
                        c.classList.remove('border-emerald-500', 'ring-2', 'ring-emerald-200');
                        c.classList.add('border-transparent');
                    });
                    img.classList.remove('border-transparent');
                    img.classList.add('border-emerald-500', 'ring-2', 'ring-emerald-200');
                    loadMockupFromUrl(fileName);
                };
                // ファイルが存在しない場合は非表示にする
                img.onerror = () => { img.style.display = 'none'; };
                sampleContainer.appendChild(img);
            });
        }

        // --- 画像読み込み ---
        function loadMockupFromUrl(url) {
            const img = new Image();
            img.onload = () => { handleMockupLoad(img); inputMockup.value = ''; };
            img.onerror = () => { /* エラー時は無視 */ };
            img.src = url;
        }

        inputMockup.addEventListener('change', (e) => {
            loadReader(e, (img) => {
                Array.from(sampleContainer.children).forEach(c => c.classList.remove('border-emerald-500', 'ring-2'));
                handleMockupLoad(img);
            });
        });

        function handleMockupLoad(img) {
            mockupImg = img;
            isSynthesized = false; 
            synthesizeStatus.textContent = "未合成";
            synthesizeStatus.className = "text-xs font-bold text-orange-500 bg-orange-50 px-2 py-0.5 border border-orange-100";
            
            detectRedDots(img);
            resizeCanvasToImage(img);
            draw(); 
            
            if(coverImg) showStatus("「合成」ボタンを押してください", "blue");
            else showStatus("", "");
        }

        inputCover.addEventListener('change', (e) => {
            loadReader(e, (img) => {
                coverImg = img;
                coverPreview.src = img.src;
                coverPreviewContainer.classList.remove('hidden');
                
                isSynthesized = false; 
                synthesizeStatus.textContent = "未合成";
                synthesizeStatus.className = "text-xs font-bold text-orange-500 bg-orange-50 px-2 py-0.5 border border-orange-100";
                
                draw();
                if(mockupImg) showStatus("「合成」ボタンを押してください", "blue");
            });
        });

        function loadReader(e, callback) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (evt) => {
                const img = new Image();
                img.onload = () => callback(img);
                img.src = evt.target.result;
            };
            reader.readAsDataURL(file);
        }

        // --- 合成ボタン ---
        btnSynthesize.addEventListener('click', () => {
            if (!mockupImg) { alert("1. モックアップ画像を設定してください。"); return; }
            if (!coverImg) { alert("2. 表紙画像を選択してください。"); return; }
            if (points.length < 4) { alert("4つの角が指定されていません。"); return; }

            isSynthesized = true;
            synthesizeStatus.textContent = "合成済み";
            synthesizeStatus.className = "text-xs font-bold text-emerald-600 bg-emerald-50 px-2 py-0.5 border border-emerald-100";

            draw(); 
            showStatus("合成完了！ ダウンロード可能です", "green");
            btnDownload.disabled = false;
        });

        // --- 描画ロジック ---
        function draw(drawControls = true) {
            if (!ctx) return;
            
            // 描画品質設定
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (mockupImg) ctx.drawImage(mockupImg, 0, 0);
            else return;

            if (points.length === 4 && coverImg && isSynthesized) {
                warpImage(coverImg, points);
            }

            // 合成済みでない場合、または調整中は線を表示
            if (drawControls && points.length > 0 && !isSynthesized) {
                ctx.lineWidth = 3;
                ctx.strokeStyle = '#00ff00'; 
                if (points.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    for (let i = 1; i < points.length; i++) ctx.lineTo(points[i].x, points[i].y);
                    if (points.length === 4) ctx.closePath();
                    ctx.stroke();
                }
                points.forEach(p => {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 8, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 50, 50, 0.9)';
                    ctx.fill();
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 3; ctx.stroke();
                    ctx.shadowColor = "rgba(0,0,0,0.5)"; ctx.shadowBlur = 5;
                });
                ctx.shadowColor = "transparent"; ctx.shadowBlur = 0;
            }
        }

        // --- 画像変形ロジック (継ぎ目対策強化版) ---
        function warpImage(img, pts) {
            // グリッド数 (5x5)
            const subdivisions = 5;
            const p0 = pts[0]; // TopLeft
            const p1 = pts[1]; // TopRight
            const p2 = pts[2]; // BottomRight
            const p3 = pts[3]; // BottomLeft
            const imgW = img.width; 
            const imgH = img.height;

            for (let y = 0; y < subdivisions; y++) {
                for (let x = 0; x < subdivisions; x++) {
                    const u1 = x / subdivisions;
                    const v1 = y / subdivisions;
                    const u2 = (x + 1) / subdivisions;
                    const v2 = (y + 1) / subdivisions;

                    // ソース領域
                    const sx = u1 * imgW;
                    const sy = v1 * imgH;
                    const sw = ((x + 1) / subdivisions - u1) * imgW;
                    const sh = ((y + 1) / subdivisions - v1) * imgH;

                    // 変換先座標を計算
                    const d1 = interpolate(p0, p1, p2, p3, u1, v1);
                    const d2 = interpolate(p0, p1, p2, p3, u2, v1);
                    const d3 = interpolate(p0, p1, p2, p3, u2, v2);
                    const d4 = interpolate(p0, p1, p2, p3, u1, v2);

                    // 2つの三角形に分割して描画
                    // renderTriangleの内部でクリップ領域を拡大して継ぎ目を消す
                    renderTriangle(img, sx, sy, sw, sh, d1, d2, d4); // 上三角
                    renderTriangle(img, sx, sy, sw, sh, d2, d3, d4); // 下三角
                }
            }
        }

        function interpolate(p0, p1, p2, p3, u, v) {
            // バイリニア補間による座標計算
            const topX = p0.x + (p1.x - p0.x) * u;
            const topY = p0.y + (p1.y - p0.y) * u;
            const bottomX = p3.x + (p2.x - p3.x) * u;
            const bottomY = p3.y + (p2.y - p3.y) * u;
            return { x: topX + (bottomX - topX) * v, y: topY + (bottomY - topY) * v };
        }

        // --- 三角形描画関数 (安全対策済み) ---
        function renderTriangle(img, sx, sy, sw, sh, p0, p1, p2) {
            ctx.save();

            // 1. クリップパスの設定 (隙間対策)
            // 重心から外側にわずかに(3%)拡大する
            const cx = (p0.x + p1.x + p2.x) / 3;
            const cy = (p0.y + p1.y + p2.y) / 3;
            const s = 1.03; 

            ctx.beginPath();
            ctx.moveTo(cx + (p0.x - cx)*s, cy + (p0.y - cy)*s);
            ctx.lineTo(cx + (p1.x - cx)*s, cy + (p1.y - cy)*s);
            ctx.lineTo(cx + (p2.x - cx)*s, cy + (p2.y - cy)*s);
            ctx.closePath();
            ctx.clip();

            // 2. アフィン変換行列の計算
            // (sx, sy) -> p0, (sx+sw, sy) -> p1, (sx, sy+sh) -> p2 の対応関係を解く
            // ソース矩形の3点 (左上, 右上, 左下) をターゲットの p0, p1, p2 にマップする
            // これにより、三角形の形状に歪ませる
            
            const x0 = sx, y0 = sy;
            const x1 = sx + sw, y1 = sy;
            const x2 = sx, y2 = sy + sh;

            const den = x0 * (y2 - y1) - x1 * y2 + x2 * y1 + (x1 - x2) * y0;
            
            // ゼロ除算ガード
            if (Math.abs(den) < 0.001) { ctx.restore(); return; }

            const a = -(y0 * (p2.x - p1.x) - y1 * p2.x + y2 * p1.x + (y1 - y2) * p0.x) / den;
            const b = -(y0 * (p2.y - p1.y) - y1 * p2.y + y2 * p1.y + (y1 - y2) * p0.y) / den;
            const c = (x0 * (p2.x - p1.x) - x1 * p2.x + x2 * p1.x + (x1 - x2) * p0.x) / den;
            const d = (x0 * (p2.y - p1.y) - x1 * p2.y + x2 * p1.y + (x1 - x2) * p0.y) / den;
            const e = (x0 * (y2 * p1.x - y1 * p2.x) + y0 * (x1 * p2.x - x2 * p1.x) + (x2 * y1 - x1 * y2) * p0.x) / den;
            const f = (x0 * (y2 * p1.y - y1 * p2.y) + y0 * (x1 * p2.y - x2 * p1.y) + (x2 * y1 - x1 * y2) * p0.y) / den;

            // 行列適用
            ctx.transform(a, b, c, d, e, f);

            // ソース画像全体を描画 (クリップ領域外は描画されない)
            ctx.drawImage(img, 0, 0);
            
            ctx.restore();
        }

        // --- ヘルパー ---
        function detectRedDots(img) {
            const w = img.width; const h = img.height;
            // 解析用の一時Canvas
            const tCvs = document.createElement('canvas'); tCvs.width = w; tCvs.height = h;
            const tCtx = tCvs.getContext('2d'); tCtx.drawImage(img, 0, 0);
            const data = tCtx.getImageData(0, 0, w, h).data;
            const found = [];

            // 簡易高速スキャン (全画素チェック)
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const i = (y * w + x) * 4;
                    // 赤色判定: R>200, G<60, B<60
                    if (data[i] > 200 && data[i+1] < 60 && data[i+2] < 60) {
                         const isNear = found.some(p => Math.abs(p.x - x) < w*0.01 && Math.abs(p.y - y) < h*0.01);
                         if (!isNear) found.push({x,y});
                    }
                }
            }
            if (found.length === 4) {
                found.sort((a,b) => a.y - b.y);
                const tops = [found[0], found[1]].sort((a,b) => a.x - b.x);
                const bots = [found[2], found[3]].sort((a,b) => a.x - b.x);
                points = [tops[0], tops[1], bots[1], bots[0]];
                return true;
            }
            return false;
        }

        function resizeCanvasToImage(img) {
            canvas.width = img.width; canvas.height = img.height;
            canvas.classList.remove('hidden'); placeholderText.classList.add('hidden');
        }

        function showStatus(msg, color) {
            if (!msg) { statusBox.classList.add('hidden'); return; }
            statusBox.classList.remove('hidden', 'bg-blue-50', 'border-blue-200', 'bg-green-50', 'border-green-200', 'bg-emerald-50', 'border-emerald-200');
            statusMessage.className = "text-sm font-bold flex items-center gap-2";
            
            if (color === 'blue') { 
                statusBox.classList.add('bg-indigo-50', 'border-indigo-200'); 
                statusMessage.classList.add('text-indigo-800'); 
            } else if (color === 'green') { 
                statusBox.classList.add('bg-emerald-50', 'border-emerald-200'); 
                statusMessage.classList.add('text-emerald-800'); 
            }
            statusMessage.textContent = msg;
        }

        // マウス操作
        function getPos(e) {
            const r = canvas.getBoundingClientRect();
            const sx = canvas.width / r.width; const sy = canvas.height / r.height;
            const cx = e.touches ? e.touches[0].clientX : e.clientX;
            const cy = e.touches ? e.touches[0].clientY : e.clientY;
            return { x: (cx - r.left) * sx, y: (cy - r.top) * sy };
        }
        
        canvas.addEventListener('mousedown', e => {
            if(!mockupImg) return; 
            if (isSynthesized) {
                isSynthesized = false;
                synthesizeStatus.textContent = "調整中";
                synthesizeStatus.className = "text-xs font-bold text-orange-500 bg-orange-50 px-2 py-0.5 border border-orange-100";
                showStatus("調整後に再度「合成」ボタンを押してください", "blue");
                draw();
                return;
            }
            const p = getPos(e);
            let idx = points.findIndex(pt => (pt.x-p.x)**2 + (pt.y-p.y)**2 < HIT_RADIUS**2);
            if(idx !== -1) { isDragging=true; dragPointIndex=idx; }
            else if(points.length < MAX_POINTS) { points.push(p); draw(); }
        });
        
        canvas.addEventListener('mousemove', e => {
            if(!mockupImg) return; const p = getPos(e);
            if(isDragging && dragPointIndex!==-1) { points[dragPointIndex]=p; draw(); }
            else { 
                const isNear = points.some(pt => (pt.x-p.x)**2 + (pt.y-p.y)**2 < HIT_RADIUS**2);
                canvas.style.cursor = isNear ? 'move' : (points.length < 4 ? 'crosshair' : 'default');
            }
        });
        const endDrag = () => { isDragging=false; dragPointIndex=-1; };
        canvas.addEventListener('mouseup', endDrag); canvas.addEventListener('mouseleave', endDrag);

        btnReset.addEventListener('click', () => {
            points=[]; mockupImg=null; coverImg=null; isSynthesized=false;
            inputMockup.value=''; inputCover.value=''; coverPreviewContainer.classList.add('hidden');
            canvas.classList.add('hidden'); placeholderText.classList.remove('hidden');
            showStatus("", ""); synthesizeStatus.textContent="未合成"; 
            synthesizeStatus.className = "text-xs font-bold text-orange-500 bg-orange-50 px-2 py-0.5 border border-orange-100";
            btnDownload.disabled=true;
            Array.from(sampleContainer.children).forEach(c => {
                c.classList.remove('border-emerald-500', 'ring-2', 'ring-emerald-200');
                c.classList.add('border-transparent');
            });
        });
        
        btnDownload.addEventListener('click', () => {
            draw(false); 
            const link = document.createElement('a'); link.download = 'mockup_result.png'; link.href = canvas.toDataURL('image/png'); link.click();
            draw(true);
        });
    </script>
</body>
</html>
