<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>本の表紙メーカー</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { 
            font-family: 'Noto Sans JP', sans-serif; 
            background-color: #f0fdfa; 
            background-image: radial-gradient(#ccfbf1 1px, transparent 1px);
            background-size: 20px 20px;
        }
        canvas { touch-action: none; }

        /* ボタンデザイン */
        .btn-rich {
            position: relative;
            overflow: hidden;
            transition: all 0.2s ease;
            z-index: 1;
            border: none; 
            border-radius: 9999px;
        }
        .btn-rich:active { transform: translateY(1px); }
        .btn-rich:disabled { opacity: 0.5; cursor: not-allowed; }
        
        /* パネル */
        .rich-panel {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid #e2e8f0;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            border-radius: 12px;
        }

        /* スクロールバー */
        .custom-scrollbar::-webkit-scrollbar { width: 6px; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
    </style>
</head>
<body class="min-h-screen flex flex-col text-gray-800">

    <header class="bg-gradient-to-r from-emerald-500 via-teal-500 to-cyan-600 p-4 shadow-lg">
        <div class="container mx-auto">
            <h1 class="text-2xl font-extrabold text-white tracking-wide drop-shadow-md">
                本の表紙メーカー
            </h1>
        </div>
    </header>

    <main class="flex-grow container mx-auto p-4 flex flex-col lg:flex-row gap-6">
        
        <!-- 左カラム -->
        <div class="w-full lg:w-1/3 flex flex-col gap-4">
            
            <div id="statusBox" class="hidden p-3 rounded border-l-4 shadow-sm text-sm font-bold">
                <p id="statusMessage"></p>
            </div>

            <div class="rich-panel p-5 space-y-6">
                
                <!-- 1. 背景設定 -->
                <div>
                    <label class="block text-sm font-bold mb-2 text-gray-700">
                        <span class="text-emerald-600 font-extrabold text-xs mr-1">STEP 1</span>
                        モックアップ画像 (背景)
                    </label>
                    
                    <!-- サンプル選択 (横6列) -->
                    <div class="bg-slate-50 p-2 border rounded-lg mb-3">
                        <div class="text-xs text-slate-500 mb-1 font-bold">サンプルから選択</div>
                        <!-- grid-cols-6 に変更し、gapを狭く -->
                        <div id="sampleContainer" class="grid grid-cols-6 gap-1 max-h-32 overflow-y-auto custom-scrollbar pr-1">
                            <!-- JSで生成 -->
                        </div>
                    </div>

                    <!-- ファイルアップロード -->
                    <div class="text-xs text-gray-500 mb-1 pl-1">または画像をアップロード</div>
                    <input type="file" id="inputMockup" accept="image/*" class="block w-full text-xs text-slate-500 file:mr-2 file:py-1 file:px-3 file:rounded-full file:border-0 file:text-xs file:font-bold file:bg-emerald-50 file:text-emerald-700 hover:file:bg-emerald-100 cursor-pointer">
                </div>
                
                <div class="border-t border-dashed border-gray-200"></div>

                <!-- 2. 表紙設定 -->
                <div>
                    <label class="block text-sm font-bold mb-2 text-gray-700">
                        <span class="text-indigo-600 font-extrabold text-xs mr-1">STEP 2</span>
                        表紙画像 (中身)
                    </label>
                    
                    <div class="flex items-center gap-2 mb-2">
                        <input type="file" id="inputCover" accept="image/*" class="block w-full text-xs text-slate-500 file:mr-2 file:py-1 file:px-3 file:rounded-full file:border-0 file:text-xs file:font-bold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100 cursor-pointer">
                        
                        <button id="btnSynthesize" class="btn-rich bg-gradient-to-br from-indigo-500 to-violet-600 text-white font-bold py-1.5 px-4 text-sm shadow-md hover:shadow-lg disabled:opacity-50 disabled:cursor-not-allowed whitespace-nowrap">
                            合成
                        </button>
                    </div>
                    
                    <div id="coverPreviewContainer" class="hidden bg-slate-50 p-2 border rounded-lg text-center">
                        <div class="flex justify-between items-center mb-1 px-1">
                            <span class="text-[10px] text-slate-500 font-bold">選択中:</span>
                            <span id="synthesizeStatus" class="text-[10px] font-bold text-orange-500 bg-white px-1.5 rounded border">未合成</span>
                        </div>
                        <img id="coverPreview" class="h-16 w-auto object-contain mx-auto shadow-sm bg-white">
                    </div>
                </div>
            </div>

            <div class="grid grid-cols-2 gap-3">
                <button id="btnReset" class="btn-rich bg-white text-slate-600 font-bold py-2 px-4 text-sm border border-slate-200 hover:bg-slate-50">
                    全クリア
                </button>
                <button id="btnDownload" class="btn-rich bg-gradient-to-br from-cyan-500 to-blue-600 text-white font-bold py-2 px-4 text-sm shadow-md hover:shadow-lg disabled:opacity-50">
                    ダウンロード
                </button>
            </div>
        </div>

        <!-- 右カラム: キャンバス -->
        <div class="w-full lg:w-2/3 rich-panel shadow-xl flex justify-center items-center overflow-hidden relative min-h-[500px] bg-slate-100" id="canvasContainer">
            <div class="absolute inset-0 pointer-events-none" style="background-image: radial-gradient(#94a3b8 1px, transparent 1px); background-size: 20px 20px; opacity: 0.1;"></div>
            <canvas id="mainCanvas" class="max-w-full max-h-[85vh] shadow-2xl hidden relative z-10"></canvas>
            <div id="placeholderText" class="text-slate-400 pointer-events-none text-center z-10 text-sm">
                左のパネルから設定してください
            </div>
        </div>
    </main>

    <footer class="bg-slate-800 text-slate-400 py-4 text-center text-xs mt-8">
        &copy; 2025 chiikuji
    </footer>

    <script>
        // --- 設定 ---
        const SAMPLE_FILES = ["1.png", "2.png", "3.png", "4.png", "5.png", "6.png"];
        // 大文字対応のためにリストを拡張
        const ALL_SAMPLES = [...SAMPLE_FILES, ...SAMPLE_FILES.map(f => f.replace('.png', '.PNG'))];

        // --- DOM ---
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true, alpha: true }); // アルファ有効化
        const inputMockup = document.getElementById('inputMockup');
        const inputCover = document.getElementById('inputCover');
        const btnSynthesize = document.getElementById('btnSynthesize');
        const coverPreviewContainer = document.getElementById('coverPreviewContainer');
        const coverPreview = document.getElementById('coverPreview');
        const synthesizeStatus = document.getElementById('synthesizeStatus');
        const statusBox = document.getElementById('statusBox');
        const statusMessage = document.getElementById('statusMessage');
        const btnReset = document.getElementById('btnReset');
        const btnDownload = document.getElementById('btnDownload');
        const placeholderText = document.getElementById('placeholderText');
        const sampleContainer = document.getElementById('sampleContainer');

        let mockupImg = null;
        let coverImg = null;
        let points = []; 
        const MAX_POINTS = 4;
        let isSynthesized = false;
        
        let isDragging = false;
        let dragPointIndex = -1;
        const HIT_RADIUS = 20;

        // --- 初期化 ---
        window.addEventListener('DOMContentLoaded', () => {
            initSampleGallery();
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
        });

        function initSampleGallery() {
            sampleContainer.innerHTML = "";
            // 1.png ~ 6.png を表示
            SAMPLE_FILES.forEach(fileName => {
                const div = document.createElement('div');
                // 縦長画像を見やすくするためのアスペクト比設定
                div.className = "aspect-[2/3] overflow-hidden rounded cursor-pointer border-2 border-transparent hover:border-emerald-400 transition-all bg-white shadow-sm";
                
                const img = document.createElement('img');
                img.src = fileName;
                img.className = "w-full h-full object-cover"; // 枠いっぱいに表示
                
                div.onclick = () => {
                    Array.from(sampleContainer.children).forEach(c => c.classList.remove('border-emerald-500', 'ring-2', 'ring-emerald-200'));
                    div.classList.remove('border-transparent');
                    div.classList.add('border-emerald-500', 'ring-2', 'ring-emerald-200');
                    loadMockupFromUrl(fileName);
                };
                
                // 画像読み込みエラー時は非表示（大文字版などは裏で試すロジックはここでは省略し、ファイル名通りに探す）
                img.onerror = () => { div.style.display = 'none'; };
                
                div.appendChild(img);
                sampleContainer.appendChild(div);
            });
        }

        // --- 画像処理 ---
        function loadMockupFromUrl(url) {
            const img = new Image();
            img.crossOrigin = "Anonymous";
            img.onload = () => { handleMockupLoad(img); inputMockup.value = ''; };
            // 小文字で見つからない場合、大文字を試す簡易リトライ
            img.onerror = () => {
                if (url.endsWith('.png')) {
                    const retryUrl = url.replace('.png', '.PNG');
                    const imgRetry = new Image();
                    imgRetry.onload = () => { handleMockupLoad(imgRetry); inputMockup.value = ''; };
                    imgRetry.src = retryUrl;
                } else {
                    alert("画像の読み込みに失敗しました: " + url);
                }
            };
            img.src = url;
        }

        inputMockup.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if(!file) return;
            const reader = new FileReader();
            reader.onload = (evt) => {
                const img = new Image();
                img.onload = () => handleMockupLoad(img);
                img.src = evt.target.result;
            };
            reader.readAsDataURL(file);
            // サンプル選択解除
            Array.from(sampleContainer.children).forEach(c => c.classList.remove('border-emerald-500', 'ring-2'));
        });

        function handleMockupLoad(img) {
            mockupImg = img;
            isSynthesized = false;
            synthesizeStatus.textContent = "未合成";
            synthesizeStatus.className = "text-[10px] font-bold text-orange-500 bg-white px-1.5 rounded border";
            
            detectRedDots(img);
            resizeCanvas();
            draw();
            
            if(coverImg) showStatus("「合成」ボタンを押してください", "blue");
            else showStatus("", "");
        }

        inputCover.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if(!file) return;
            const reader = new FileReader();
            reader.onload = (evt) => {
                const img = new Image();
                img.onload = () => {
                    coverImg = img;
                    coverPreview.src = img.src;
                    coverPreviewContainer.classList.remove('hidden');
                    isSynthesized = false;
                    synthesizeStatus.textContent = "未合成";
                    synthesizeStatus.className = "text-[10px] font-bold text-orange-500 bg-white px-1.5 rounded border";
                    draw();
                    if(mockupImg) showStatus("「合成」ボタンを押してください", "blue");
                };
                img.src = evt.target.result;
            };
            reader.readAsDataURL(file);
        });

        // --- 合成ロジック ---
        btnSynthesize.addEventListener('click', () => {
            if (!mockupImg) { alert("1. 背景画像を設定してください。"); return; }
            if (!coverImg) { alert("2. 表紙画像を選択してください。"); return; }
            if (points.length < 4) { alert("4つの角が指定されていません。"); return; }

            isSynthesized = true;
            synthesizeStatus.textContent = "合成済み";
            synthesizeStatus.className = "text-[10px] font-bold text-emerald-600 bg-emerald-50 px-1.5 rounded border border-emerald-200";
            
            draw(); 
            showStatus("合成完了！ ダウンロード可能です", "green");
            btnDownload.disabled = false;
        });

        // --- 描画関数 ---
        function resizeCanvas() {
            if(!mockupImg) return;
            canvas.width = mockupImg.width;
            canvas.height = mockupImg.height;
            canvas.classList.remove('hidden');
            placeholderText.classList.add('hidden');
        }

        function draw(drawControls = true) {
            if (!ctx || !mockupImg) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. 背景
            ctx.drawImage(mockupImg, 0, 0);

            // 2. 合成
            if (points.length === 4 && coverImg && isSynthesized) {
                warpImage(coverImg, points);
            }

            // 3. UI (未合成または編集中のみ表示)
            if (drawControls && points.length > 0 && !isSynthesized) {
                // 線
                ctx.lineWidth = 3;
                ctx.strokeStyle = '#00ff00'; 
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) ctx.lineTo(points[i].x, points[i].y);
                if (points.length === 4) ctx.closePath();
                ctx.stroke();

                // 点
                points.forEach(p => {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 8, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 50, 50, 0.9)';
                    ctx.fill();
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
                });
            }
        }

        // --- 【重要】修正された変形ロジック ---
        function warpImage(img, pts) {
            const subdivisions = 10; // 分割数（多いほど歪みが滑らか）
            
            // 4隅の座標: TL, TR, BR, BL
            const p0 = pts[0];
            const p1 = pts[1];
            const p2 = pts[2];
            const p3 = pts[3];
            
            const w = img.width;
            const h = img.height;

            for (let y = 0; y < subdivisions; y++) {
                for (let x = 0; x < subdivisions; x++) {
                    // グリッド座標 (0.0 ~ 1.0)
                    const u0 = x / subdivisions;
                    const v0 = y / subdivisions;
                    const u1 = (x + 1) / subdivisions;
                    const v1 = (y + 1) / subdivisions;

                    // ソース画像の切り抜き座標 (矩形)
                    const sx = u0 * w;
                    const sy = v0 * h;
                    const sw = (u1 - u0) * w;
                    const sh = (v1 - v0) * h;

                    // 変換後の4点 (四角形)
                    // バイリニア補間で座標を求める
                    const dp0 = interpolate(p0, p1, p2, p3, u0, v0); // TL
                    const dp1 = interpolate(p0, p1, p2, p3, u1, v0); // TR
                    const dp2 = interpolate(p0, p1, p2, p3, u1, v1); // BR
                    const dp3 = interpolate(p0, p1, p2, p3, u0, v1); // BL

                    // 1つの四角形を2つの三角形に分割して描画
                    // 三角形1: TL-TR-BL (ソース: 左上, 右上, 左下)
                    renderTriangle(
                        ctx, img, 
                        sx, sy,               // src x0, y0 (TL)
                        sx + sw, sy,          // src x1, y1 (TR)
                        sx, sy + sh,          // src x2, y2 (BL)
                        dp0.x, dp0.y,         // dst x0, y0
                        dp1.x, dp1.y,         // dst x1, y1
                        dp3.x, dp3.y          // dst x2, y2
                    );

                    // 三角形2: TR-BR-BL (ソース: 右上, 右下, 左下)
                    renderTriangle(
                        ctx, img,
                        sx + sw, sy,          // src x0, y0 (TR)
                        sx + sw, sy + sh,     // src x1, y1 (BR)
                        sx, sy + sh,          // src x2, y2 (BL)
                        dp1.x, dp1.y,
                        dp2.x, dp2.y,
                        dp3.x, dp3.y
                    );
                }
            }
        }

        function interpolate(p0, p1, p2, p3, u, v) {
            // 上辺と下辺の補間
            const topX = p0.x + (p1.x - p0.x) * u;
            const topY = p0.y + (p1.y - p0.y) * u;
            const bottomX = p3.x + (p2.x - p3.x) * u;
            const bottomY = p3.y + (p2.y - p3.y) * u;
            // 縦方向の補間
            const x = topX + (bottomX - topX) * v;
            const y = topY + (bottomY - topY) * v;
            return { x, y };
        }

        // アフィン変換行列を計算して描画する関数
        // src(sx0, sy0) -> dst(dx0, dy0) ... 3点の対応
        function renderTriangle(ctx, img, sx0, sy0, sx1, sy1, sx2, sy2, dx0, dy0, dx1, dy1, dx2, dy2) {
            ctx.save();

            // クリップパス設定（継ぎ目対策のため0.5px広げる）
            ctx.beginPath();
            ctx.moveTo(dx0, dy0);
            ctx.lineTo(dx1, dy1);
            ctx.lineTo(dx2, dy2);
            ctx.closePath();
            // 描画領域をわずかに拡張してクリップ（隙間を埋める重要処理）
            ctx.lineWidth = 1; 
            ctx.strokeStyle = 'rgba(0,0,0,0)'; // 透明な線を描いてパスを太らせる擬似効果
            ctx.stroke();
            ctx.clip();

            // アフィン変換行列の計算
            // x_dst = a * x_src + c * y_src + e
            // y_dst = b * x_src + d * y_src + f
            const den = sx0 * (sy2 - sy1) - sx1 * sy2 + sx2 * sy1 + (sx1 - sx2) * sy0;
            if (Math.abs(den) < 0.0001) { ctx.restore(); return; }

            const a = (dx0 * (sy2 - sy1) - dx1 * sy2 + dx2 * sy1 + (dx1 - dx2) * sy0) / den;
            const b = (dy0 * (sy2 - sy1) - dy1 * sy2 + dy2 * sy1 + (dy1 - dy2) * sy0) / den;
            const c = (sx0 * (dx1 - dx2) - sx1 * dx0 + sx2 * dx0 + (sx1 - sx2) * dx1) / den * -1; // 符号注意
            // cの計算式再確認: 
            // c = (sx0*(dx2-dx1) - sx1*dx2 + sx2*dx1 + (sx1-sx2)*dx0) / den ではない
            // 正しい式:
            const c_corr = (dx1 * sy2 - dx2 * sy1 + dx0 * (sy1 - sy2) + (dx2 - dx1) * sy0) / den * -1; // 分子が違う
            // シンプルな連立方程式の解を利用:
            
            const m11 = sx0, m12 = sy0, m13 = 1;
            const m21 = sx1, m22 = sy1, m23 = 1;
            const m31 = sx2, m32 = sy2, m33 = 1;
            // 逆行列を使って a,c,e と b,d,f を求めるのが確実
            
            // ここでは高速化のため、Canvas特有の計算式を使用
            // Transform Matrix:
            // [ a c e ]
            // [ b d f ]
            // [ 0 0 1 ]
            
            const A = -(sy0 * (dx2 - dx1) - sy1 * dx2 + sy2 * dx1 + (sy1 - sy2) * dx0) / den;
            const B = -(sy0 * (dy2 - dy1) - sy1 * dy2 + sy2 * dy1 + (sy1 - sy2) * dy0) / den;
            const C = (sx0 * (dx2 - dx1) - sx1 * dx2 + sx2 * dx1 + (sx1 - sx2) * dx0) / den;
            const D = (sx0 * (dy2 - dy1) - sx1 * dy2 + sx2 * dy1 + (sx1 - sx2) * dy0) / den;
            const E = (sx0 * (sy2 * dx1 - sy1 * dx2) + sy0 * (sx1 * dx2 - sx2 * dx1) + (sx2 * sy1 - sx1 * sy2) * dx0) / den;
            const F = (sx0 * (sy2 * dy1 - sy1 * dy2) + sy0 * (sx1 * dy2 - sx2 * dy1) + (sx2 * sy1 - sx1 * sy2) * dy0) / den;

            ctx.transform(A, B, C, D, E, F);

            // ソース画像の描画
            // 画像全体を描画すると重い＆変換範囲外が出る可能性があるため、
            // 必要な矩形部分だけを描画してもよいが、クリップされているので全体描画でOK
            ctx.drawImage(img, 0, 0);
            
            ctx.restore();
        }

        // --- 赤点検出 ---
        function detectRedDots(img) {
            const w = img.width; const h = img.height;
            const tCvs = document.createElement('canvas'); tCvs.width = w; tCvs.height = h;
            const tCtx = tCvs.getContext('2d'); tCtx.drawImage(img, 0, 0);
            const data = tCtx.getImageData(0, 0, w, h).data;
            const found = [];

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const i = (y * w + x) * 4;
                    if (data[i] > 200 && data[i+1] < 60 && data[i+2] < 60) {
                         const isNear = found.some(p => Math.abs(p.x - x) < w*0.01 && Math.abs(p.y - y) < h*0.01);
                         if (!isNear) found.push({x,y});
                    }
                }
            }
            if (found.length === 4) {
                found.sort((a,b) => a.y - b.y);
                const tops = [found[0], found[1]].sort((a,b) => a.x - b.x);
                const bots = [found[2], found[3]].sort((a,b) => a.x - b.x);
                points = [tops[0], tops[1], bots[1], bots[0]];
                return true;
            }
            return false;
        }

        // --- UIヘルパー ---
        function showStatus(msg, color) {
            if (!msg) { statusBox.classList.add('hidden'); return; }
            statusBox.classList.remove('hidden', 'bg-blue-50', 'border-blue-200', 'bg-green-50', 'border-green-200');
            statusBox.classList.add(color === 'green' ? 'bg-green-50' : 'bg-blue-50');
            statusBox.classList.add(color === 'green' ? 'border-green-200' : 'border-blue-200');
            
            const textCol = color === 'green' ? 'text-emerald-700' : 'text-indigo-700';
            statusMessage.className = `text-xs font-bold ${textCol}`;
            statusMessage.textContent = msg;
        }

        // --- マウス操作 ---
        function getPos(e) {
            const r = canvas.getBoundingClientRect();
            const sx = canvas.width / r.width; const sy = canvas.height / r.height;
            const cx = e.touches ? e.touches[0].clientX : e.clientX;
            const cy = e.touches ? e.touches[0].clientY : e.clientY;
            return { x: (cx - r.left) * sx, y: (cy - r.top) * sy };
        }
        
        canvas.addEventListener('mousedown', e => {
            if(!mockupImg) return; 
            if (isSynthesized) {
                isSynthesized = false;
                synthesizeStatus.textContent = "調整中";
                synthesizeStatus.className = "text-[10px] font-bold text-orange-500 bg-white px-1.5 rounded border";
                showStatus("調整後に再度「合成」ボタンを押してください", "blue");
                draw();
                return;
            }
            const p = getPos(e);
            let idx = points.findIndex(pt => (pt.x-p.x)**2 + (pt.y-p.y)**2 < HIT_RADIUS**2);
            if(idx !== -1) { isDragging=true; dragPointIndex=idx; }
            else if(points.length < MAX_POINTS) { points.push(p); draw(); }
        });
        
        canvas.addEventListener('mousemove', e => {
            if(!mockupImg) return; const p = getPos(e);
            if(isDragging && dragPointIndex!==-1) { points[dragPointIndex]=p; draw(); }
            else { 
                const isNear = points.some(pt => (pt.x-p.x)**2 + (pt.y-p.y)**2 < HIT_RADIUS**2);
                canvas.style.cursor = isNear ? 'move' : (points.length < 4 ? 'crosshair' : 'default');
            }
        });
        
        const endDrag = () => { isDragging=false; dragPointIndex=-1; };
        canvas.addEventListener('mouseup', endDrag); 
        canvas.addEventListener('mouseleave', endDrag);
        canvas.addEventListener('touchstart', e => { if(e.touches.length==1) handleStart({touches:e.touches, preventDefault:()=>{}}); }, {passive:false});

        btnReset.addEventListener('click', () => {
            points=[]; mockupImg=null; coverImg=null; isSynthesized=false;
            inputMockup.value=''; inputCover.value=''; coverPreviewContainer.classList.add('hidden');
            canvas.classList.add('hidden'); placeholderText.classList.remove('hidden');
            showStatus("", ""); synthesizeStatus.textContent="未合成";
            btnDownload.disabled=true;
            Array.from(sampleContainer.children).forEach(c => c.classList.remove('border-emerald-500', 'ring-2'));
        });
        
        btnDownload.addEventListener('click', () => {
            draw(false); 
            const link = document.createElement('a'); 
            link.download = 'mockup_result.png'; 
            link.href = canvas.toDataURL('image/png'); 
            link.click();
            draw(true);
        });
    </script>
</body>
</html>
